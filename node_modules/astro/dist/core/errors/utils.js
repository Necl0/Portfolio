import eol from "eol";
import stripAnsi from "strip-ansi";
function collectInfoFromStacktrace(error) {
  var _a, _b, _c;
  if (!error.stack)
    return error;
  error.stack = eol.lf(error.stack);
  const stackText = stripAnsi(error.stack);
  if (!error.loc || !error.loc.column && !error.loc.line) {
    const possibleFilePath = ((_a = error.loc) == null ? void 0 : _a.file) || error.pluginCode || error.id || stackText.split("\n").find((ln) => ln.includes("src") || ln.includes("node_modules"));
    const source = possibleFilePath == null ? void 0 : possibleFilePath.replace(/^[^(]+\(([^)]+).*$/, "$1").replace(/^\s+at\s+/, "");
    const [file, line, column] = (source == null ? void 0 : source.split(":")) ?? [];
    if (line && column) {
      error.loc = {
        file,
        line: Number.parseInt(line),
        column: Number.parseInt(column)
      };
    }
  }
  if (!error.plugin) {
    error.plugin = ((_b = /withastro\/astro\/packages\/integrations\/([\w-]+)/gim.exec(stackText)) == null ? void 0 : _b.at(1)) || ((_c = /(@astrojs\/[\w-]+)\/(server|client|index)/gim.exec(stackText)) == null ? void 0 : _c.at(1)) || void 0;
  }
  error.stack = cleanErrorStack(error.stack);
  return error;
}
function cleanErrorStack(stack) {
  return stack.split(/\n/g).map((l) => l.replace(/\/@fs\//g, "/")).join("\n");
}
function positionAt(offset, text) {
  const lineOffsets = getLineOffsets(text);
  offset = Math.max(0, Math.min(text.length, offset));
  let low = 0;
  let high = lineOffsets.length;
  if (high === 0) {
    return {
      line: 0,
      column: offset
    };
  }
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    const lineOffset = lineOffsets[mid];
    if (lineOffset === offset) {
      return {
        line: mid,
        column: 0
      };
    } else if (offset > lineOffset) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  const line = low - 1;
  return { line, column: offset - lineOffsets[line] };
}
function getLineOffsets(text) {
  const lineOffsets = [];
  let isLineStart = true;
  for (let i = 0; i < text.length; i++) {
    if (isLineStart) {
      lineOffsets.push(i);
      isLineStart = false;
    }
    const ch = text.charAt(i);
    isLineStart = ch === "\r" || ch === "\n";
    if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
      i++;
    }
  }
  if (isLineStart && text.length > 0) {
    lineOffsets.push(text.length);
  }
  return lineOffsets;
}
function createSafeError(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
export {
  collectInfoFromStacktrace,
  createSafeError,
  positionAt
};
