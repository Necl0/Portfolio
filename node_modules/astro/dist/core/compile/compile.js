import { transform } from "@astrojs/compiler";
import { AstroErrorCodes } from "../errors/codes.js";
import { AggregateError, CompilerError } from "../errors/errors.js";
import { prependForwardSlash } from "../path.js";
import { resolvePath, viteID } from "../util.js";
import { createStylePreprocessor } from "./style.js";
const configCache = /* @__PURE__ */ new WeakMap();
async function compile({
  astroConfig,
  viteConfig,
  filename,
  source
}) {
  var _a;
  let cssDeps = /* @__PURE__ */ new Set();
  let cssTransformErrors = [];
  const transformResult = await transform(source, {
    pathname: filename,
    projectRoot: astroConfig.root.toString(),
    site: (_a = astroConfig.site) == null ? void 0 : _a.toString(),
    sourcefile: filename,
    sourcemap: "both",
    internalURL: `/@fs${prependForwardSlash(
      viteID(new URL("../../runtime/server/index.js", import.meta.url))
    )}`,
    experimentalStaticExtraction: true,
    preprocessStyle: createStylePreprocessor({
      filename,
      viteConfig,
      cssDeps,
      cssTransformErrors
    }),
    async resolvePath(specifier) {
      return resolvePath(specifier, filename);
    }
  }).catch((err) => {
    throw new CompilerError({
      errorCode: AstroErrorCodes.UnknownCompilerError,
      message: err.message ?? "Unknown compiler error",
      stack: err.stack,
      location: {
        file: filename
      }
    });
  }).then((result) => {
    const compilerError = result.diagnostics.find(
      (diag) => diag.severity === 1 && diag.code < 2e3
    );
    if (compilerError) {
      throw new CompilerError({
        errorCode: compilerError.code,
        message: compilerError.text,
        location: {
          line: compilerError.location.line,
          column: compilerError.location.column,
          file: compilerError.location.file
        },
        hint: compilerError.hint ? compilerError.hint : void 0
      });
    }
    switch (cssTransformErrors.length) {
      case 0:
        return result;
      case 1: {
        let error = cssTransformErrors[0];
        if (!error.errorCode) {
          error.errorCode = AstroErrorCodes.UnknownCompilerCSSError;
        }
        throw cssTransformErrors[0];
      }
      default: {
        throw new AggregateError({ ...cssTransformErrors[0], errors: cssTransformErrors });
      }
    }
  });
  const compileResult = Object.create(transformResult, {
    cssDeps: {
      value: cssDeps
    },
    source: {
      value: source
    }
  });
  return compileResult;
}
function isCached(config, filename) {
  return configCache.has(config) && configCache.get(config).has(filename);
}
function getCachedSource(config, filename) {
  if (!isCached(config, filename))
    return null;
  let src = configCache.get(config).get(filename);
  if (!src)
    return null;
  return src.source;
}
function invalidateCompilation(config, filename) {
  if (configCache.has(config)) {
    const cache = configCache.get(config);
    cache.delete(filename);
  }
}
async function cachedCompilation(props) {
  const { astroConfig, filename } = props;
  let cache;
  if (!configCache.has(astroConfig)) {
    cache = /* @__PURE__ */ new Map();
    configCache.set(astroConfig, cache);
  } else {
    cache = configCache.get(astroConfig);
  }
  if (cache.has(filename)) {
    return cache.get(filename);
  }
  const compileResult = await compile(props);
  cache.set(filename, compileResult);
  return compileResult;
}
export {
  cachedCompilation,
  getCachedSource,
  invalidateCompilation,
  isCached
};
